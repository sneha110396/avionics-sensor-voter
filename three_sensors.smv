-- Module realWorld will generate signal values between a given range

MODULE realWorld                    

DEFINE
	MAX_VAL:= 10;		  -- maximum value of the signal
	MIN_VAL:= -10;		  -- minimum value of the signal

VAR
	out : MIN_VAL..MAX_VAL;   -- variable to generate random signal values between MIN_VAL and MAX_VAL

-----------------------------------------------------------------------------------------------------------------------------------------------------

-- Module sensor will create sensors which will measure the signal values created by realWorld Module
-- It takes the realWorld module as input
-- Each sensor will have a noise. Each sensor can have three types of "fault"
-- Each sensor will output a signal value and a hardware flag
-- hardware flag of each sensor indicates if there is a hardware fault in the sensor or not

MODULE sensor(world)

VAR
	hw_valid: boolean;         -- TRUE means hardware flag is indicating valid, FALSE otherwise
	
	fault: 0..2;               -- 0 means no fault
	                           -- 1 means signal is an arbitrary value
				   -- 2 means hw_valid may not be correct
				   
	noise: -1..1;              -- noise can be between -1 to 1
	
	signal: (world.MIN_VAL) .. (world.MAX_VAL); 
	
	

ASSIGN
	init(fault) := 0;                                     -- intially fault is 0
							      -- each step it will take arbitrary value between 0 to 2
							      
	init(hw_valid) := TRUE;                               -- hw_valid is TRUE initially
	next(hw_valid) := case				      -- In each step, if fault is 0, hw_valid will be true
				fault=0 : TRUE;		      -- Otherwise it will take arbitrary boolean value
				TRUE : {TRUE , FALSE};
				esac;
				
	-- If fault is 0, signal value will be realWorld value + noise
	-- If the signal value exceeds the MAX_VAL, we will set the signal value as MAX_VAL
	-- If signal value becomes less than MIN_VAL, we will set the signal value as MIN_VAL
	-- If fault is not 0, signal can take any arbitrary value between MAX_VAL and MIN_VAL
	
	init(signal) := case
			fault=0 & (abs(world.out + noise) <=world.MAX_VAL) : world.out + noise;
			fault=0 & ((world.out + noise) > world.MAX_VAL) : world.MAX_VAL;
			fault=0 & ((world.out + noise) < world.MIN_VAL) : world.MIN_VAL;
			esac;
	next(signal) := case
			next(fault)=0 & (abs(next(world.out) + next(noise)) <=world.MAX_VAL) : next(world.out) + next(noise);
			next(fault)=0 & ((next(world.out) + next(noise)) > world.MAX_VAL) : world.MAX_VAL;
			next(fault)=0 & ((next(world.out) + next(noise)) < world.MIN_VAL) : world.MIN_VAL;
			TRUE : -10..10;
			esac;
			
------------------------------------------------------------------------------------------------------------------------------------------------------


-- Main module will work as the voter here

MODULE main               			       

DEFINE
	HW_PERSISTENCE := 4;                           -- hardware persistence 
	MC_PERSISTENCE := 4;                           -- miscompare persistence
    	MC_val_threshold := 2;                         -- two sensor miscompare if their signal value differ more than this threshold

VAR
   	rWorld : realWorld();			       -- Instance of the realWorld module
	
	sensor1 : sensor(rWorld);		       -- First Instance of sensor module
	sensor2 : sensor(rWorld);		       -- Second instance of sensor module
	sensor3 : sensor(rWorld);		       -- Third instance of sensor module
	
	hw_count1: 0..HW_PERSISTENCE;                  -- variable to measure hardware error persistence of sensor 1
	hw_count2: 0..HW_PERSISTENCE;                  -- variable to measure hardware error persistence of sensor 2
	hw_count3: 0..HW_PERSISTENCE;                  -- variable to measure hardware error persistence of sensor 3
	
	mc_count1: 0..MC_PERSISTENCE;                  -- variable to measure miscompare persistence of sensor 1 with sensor 2 and 3
	mc_count2: 0..MC_PERSISTENCE;                  -- variable to measure miscompare persistence of sensor 2 with sensor 3 and 1
	mc_count3: 0..MC_PERSISTENCE;                  -- variable to measure miscompare persistence of sensor 3 with sensor 1 snd 2
	
	isolated1 : boolean;                           -- TRUE if sensor 1 is isolated
	isolated2 : boolean;                           -- TRUE if sensor 2 is isolated
	isolated3 : boolean;                           -- TRUE if sendor 3 is isolated
	
	landmark : {"reset", "thres_hit"};             -- variable to indicate if the miscompare variable reached threshold or did reset
	

ASSIGN 
	
	init(isolated1) := FALSE;
	next(isolated1) := case
				(hw_count1=HW_PERSISTENCE) | (numActive=3 & mc_count1=MC_PERSISTENCE) : TRUE;
				isolated1 : TRUE;
				TRUE : FALSE;
				esac;
	init(isolated2) := FALSE;
	next(isolated2) := case
				(hw_count2=HW_PERSISTENCE) | (numActive=3 & mc_count2=MC_PERSISTENCE) : TRUE;
				isolated2 : TRUE;
				TRUE : FALSE;
				esac;
	init(isolated3) := FALSE;
	next(isolated3) := case
				(hw_count3=HW_PERSISTENCE) | (numActive=3 & mc_count3=MC_PERSISTENCE) : TRUE;
				isolated3 : TRUE;
				TRUE : FALSE;
				esac;
	init(hw_count1) := 0;
	next(hw_count1) := case
				(next(sensor1.hw_valid) = FALSE) & (hw_count1<HW_PERSISTENCE) : hw_count1+1;
				next(sensor1.hw_valid) = TRUE : 0;
				hw_count1=HW_PERSISTENCE : HW_PERSISTENCE;
				TRUE : hw_count1;
				esac;
	init(hw_count2) := 0;
	next(hw_count2) := case
				(next(sensor2.hw_valid) = FALSE) & (hw_count2<HW_PERSISTENCE) : hw_count2+1;
				next(sensor2.hw_valid) = TRUE : 0;
				hw_count2=HW_PERSISTENCE : HW_PERSISTENCE;
				TRUE : hw_count2;
				esac;
	init(hw_count3) := 0;
	next(hw_count3) := case
				(next(sensor3.hw_valid) = FALSE) & (hw_count3<HW_PERSISTENCE) : hw_count3+1;
				next(sensor3.hw_valid) = TRUE : 0;
				hw_count3=HW_PERSISTENCE : HW_PERSISTENCE;
				TRUE : hw_count3;
				esac;
	init(mc_count1) := 0;
	next(mc_count1) := case
				(next(numActive)=3) & next(miscompare1)=TRUE & (mc_count1<MC_PERSISTENCE) : mc_count1 +1;
				(next(numActive)=3) & next(miscompare1)=FALSE & (mc_count1<MC_PERSISTENCE): 0;
				(numActive=3) & (mc_count1=MC_PERSISTENCE) : 0;

				next(numActive)=2 & next(isolated1)=TRUE & (next(diff_23) > MC_val_threshold) & (mc_count1 < MC_PERSISTENCE): mc_count1+1;
				next(numActive)=2 & next(isolated1)=TRUE & next(landmark)= "reset" & (next(diff_23) <= MC_val_threshold) : 0;
				next(numActive)=2 & next(isolated1)=TRUE & next(landmark)= "thres_hit" & (next(diff_23) <= MC_val_threshold) & (mc_count1 >0) : mc_count1 - 1;
				TRUE : mc_count1;
				esac;
	init(mc_count2) := 0;
	next(mc_count2) := case
				(next(numActive)=3) & next(miscompare2)=TRUE & (mc_count2<MC_PERSISTENCE) : mc_count2 +1;
				(next(numActive)=3) & next(miscompare2)=FALSE & (mc_count2<MC_PERSISTENCE): 0;
				(numActive=3) & (mc_count2=MC_PERSISTENCE) : 0;

				next(numActive)=2 & next(isolated2)=TRUE & (next(diff_13) > MC_val_threshold) & (mc_count2 < MC_PERSISTENCE): mc_count2+1;
				next(numActive)=2 & next(isolated2)=TRUE & next(landmark)="reset" & (next(diff_13) <= MC_val_threshold) : 0;
				next(numActive)=2 & next(isolated2)=TRUE & next(landmark)="thres_hit" & (next(diff_13) <= MC_val_threshold) & (mc_count2 >0) : mc_count2 - 1;
				TRUE : mc_count2;
				esac;
	init(mc_count3) := 0;
	next(mc_count3) := case
				next(numActive)=3 & next(miscompare3)=TRUE & (mc_count3<MC_PERSISTENCE) : mc_count3 +1;
				next(numActive)=3 & next(miscompare3)=FALSE & (mc_count3<MC_PERSISTENCE) : 0;
				(numActive=3) & (mc_count3=MC_PERSISTENCE) : 0;

				next(numActive)=2 & next(isolated3)=TRUE & (next(diff_12) > MC_val_threshold) & (mc_count3 < MC_PERSISTENCE): mc_count3+1;
				next(numActive)=2 & next(isolated3)=TRUE & next(landmark)="reset" & (next(diff_12) <= MC_val_threshold) : 0;
				next(numActive)=2 & next(isolated3)=TRUE & next(landmark)="thres_hit" & (next(diff_12) <= MC_val_threshold) & (mc_count3 >0) : mc_count3 - 1;
				TRUE : mc_count3;
				esac;

	init(landmark):= "reset";
	next(landmark):= case
						numActive=2 & isolated1 & mc_count1=MC_PERSISTENCE : "thres_hit";
						numActive=2 & isolated2 & mc_count2=MC_PERSISTENCE : "thres_hit";
						numActive=2 & isolated3 & mc_count3=MC_PERSISTENCE : "thres_hit";
						numActive=2 & isolated1 & mc_count1=0 : "reset";
						numActive=2 & isolated2 & mc_count2=0 : "reset";
						numActive=2 & isolated3 & mc_count3=0 : "reset";
						TRUE: landmark;
						esac;
				
							
DEFINE
	diff_12 := abs(sensor1.signal - sensor2.signal);
	diff_23 := abs(sensor2.signal - sensor3.signal);
	diff_13 := abs(sensor1.signal - sensor3.signal);
	miscompare3 :=  (diff_13 > MC_val_threshold) & (diff_23 > MC_val_threshold);
	miscompare2 :=  (diff_12 > MC_val_threshold) & (diff_23 > MC_val_threshold);
	miscompare1 :=  (diff_13 > MC_val_threshold) & (diff_12 > MC_val_threshold);
	numActive := case
			!isolated1 & !isolated2 & !isolated3 : 3;
			(isolated1 & !isolated2 & !isolated3) | (!isolated1 & isolated2 & !isolated3) | (!isolated1 & !isolated2 & isolated3) : 2;
			(isolated1 & isolated2 & !isolated3) | (!isolated1 & isolated2 & isolated3) | (isolated1 & !isolated2 & isolated3) : 1;
			isolated1 & isolated2 & isolated3 : 0;
			esac;
	outputSignal := case
			numActive=3 : (sensor1.signal + sensor2.signal + sensor3.signal)/3;
			numActive=2 & isolated1: (sensor2.signal + sensor3.signal)/2;
			numActive=2 & isolated2: (sensor3.signal + sensor1.signal)/2;
			numActive=2 & isolated3: (sensor1.signal + sensor2.signal)/2;
			numActive=1 & isolated1 & isolated2 : sensor3.signal;
			numActive=1 & isolated2 & isolated3 : sensor1.signal;
			numActive=1 & isolated3 & isolated1 : sensor2.signal;
			numActive=0 : -100;
			esac;

	outputValid := case 
						numActive=3 : TRUE;

						numActive=2 & isolated1 & mc_count1=MC_PERSISTENCE : FALSE;
						numActive=2 & isolated1 & mc_count1=0 : TRUE;
						numActive=2 & isolated1 & mc_count1 < MC_PERSISTENCE & mc_count1 > 0 & landmark="thres_hit": FALSE;
						numActive=2 & isolated1 & mc_count1 < MC_PERSISTENCE & mc_count1 > 0 & landmark="reset": TRUE;
				
						numActive=2 & isolated2 & mc_count2=MC_PERSISTENCE : FALSE;
						numActive=2 & isolated2 & mc_count2=0 : TRUE;
						numActive=2 & isolated2 & mc_count2 < MC_PERSISTENCE & mc_count2 > 0 & landmark="thres_hit": FALSE;
						numActive=2 & isolated2 & mc_count2 < MC_PERSISTENCE & mc_count2 > 0 & landmark="reset": TRUE;
						
						numActive=2 & isolated3 & mc_count3=MC_PERSISTENCE : FALSE;
						numActive=2 & isolated3 & mc_count3=0 : TRUE;
						numActive=2 & isolated3 & mc_count3 < MC_PERSISTENCE & mc_count3 > 0 & landmark="thres_hit": FALSE;
						numActive=2 & isolated3 & mc_count3 < MC_PERSISTENCE & mc_count3 > 0 & landmark="reset": TRUE;
						
						numActive=1 : TRUE;
						numActive=0 : FALSE;
						esac;
	
	isolt_or_count_lt_persist := (!isolated1 -> hw_count1 < HW_PERSISTENCE) & (!isolated2 -> hw_count2 < HW_PERSISTENCE) & (!isolated3 -> hw_count3 < HW_PERSISTENCE);
	no_hardware_fault := (!isolated1 -> sensor1.hw_valid=TRUE) & (!isolated2 -> sensor2.hw_valid=TRUE) & (!isolated3 -> sensor3.hw_valid=TRUE);


--Invariants	

INVAR !((isolated1=FALSE & sensor1.fault!=0) & (isolated2=FALSE & sensor2.fault!=0)) 
INVAR !((isolated1=FALSE & sensor1.fault!=0) & (isolated3=FALSE & sensor3.fault!=0))
INVAR !((isolated2=FALSE & sensor2.fault!=0) & (isolated3=FALSE & sensor3.fault!=0))


--properties to check

CTLSPEC AG(numActive=2-> (AG(numActive!=3)))
CTLSPEC AG(numActive=1-> (AG(numActive!=2)))
CTLSPEC AG(numActive=0-> (!EF(numActive=1))) 
CTLSPEC AG(numActive=3 -> EF(numActive=2))
CTLSPEC AG(numActive=2 -> EF(numActive=1))
CTLSPEC AG(numActive=1-> EF(numActive=0))
CTLSPEC AG((outputSignal= rWorld.out) -> AF(A[(outputSignal = rWorld.out) U ((outputSignal= rWorld.out) & outputValid)] | (outputSignal = rWorld.out)))
CTLSPEC AG((numActive=2 & outputValid & isolt_or_count_lt_persist) -> EF(numActive=2 & !outputValid))
